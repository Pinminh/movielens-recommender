# A comprehensive survey into movie recommender systems and it application on movielens dataset

## Abstract
As information increase by days, the ability of extracting new, relevant movies become more clearly difficult. This issue has motivated notion of a recommender system, which turn into an essential component of various softwares, and an important part of user's daily basis.  
This report serves as our introductory survey, which stems from curriculum of Ho Chi Minh City Universy of Technology (HCMUT), into the field of recommender systems. To this end, we'll choose collaborative filtering among various approaches, then proceed to study in-depth related techniques and algorithms: Slope One algorithm, k-Nearest Neighbors based algorithm, and Singular Value Decomposition based algorithm.  
Finally, we'll assess these algorithms on movielens dataset by means of different popular metrics. Discussion on strength and limitation of said techniques will also be included.

# 1. Introduction
Our brief introduction will focus on reasons and motivations behind choosing the subject of movie recommender system in our survey. This ideally lead to a more detailed view on recommender system in general together with its techniques and approaches. We'll keep our discussion as organized as possible.

## 1.1 Motivation for movies recommender systems
Our topic is chosen based on the essential nature of movies recommender systems. In modern days, the amount of information has an explosive growth. The rapid production of movies makes services, for example a website for watching movies, offer an overwhelming number of movies. The freedom in movie choices, instead of providing benefits, leads to users' poor choices. Sometimes, it's even impossible to choose a good one from this available sea of movies.  
To make the problem more complex, each user has their own preference and taste on movie. They'll like some movies while dislike others in terms of genres, tags, length, views... of said movies. By this observation, we'll also need to take user's personalization into account, in case we want to increase users' satisfaction.  
These problems are addressed by recommender systems. Specifically, a movies recommender system would point users towards new, not-yet-experienced movies that are relevant to the users. Those recommendations could be either accepted or rejected, the users can browse through all recommendations available and they may or may not provide feedback. All user actions could be stored, then used by recommender system to generate more accurate results.  
With its important role in modern services, recommender systems have gained enormous interests from researchers and organizations. Not only for movies, many other services have employed recommender system in their feature list, typical examples are highly rated applications such as [Amazon](https://www.amazon.com/), [Youtube](https://www.youtube.com/), [Netflix](https://www.netflix.com/), [IMDb](https://www.imdb.com/), [Spotify](https://open.spotify.com/), [Tripadvisor](https://www.tripadvisor.com/)... Many communities, conferences, workshops are dedicated to the topic of recommender systems, [ACM Recommender Systems (RecSys)](https://recsys.acm.org/) is one of the brightest ones. More and more studies, researches have been conducted on the subject, a lot of journals have dedicated to recommender systems, some of them are [AI Communications](https://www.aicommunications.eu/) (2008), [IEEE Intelligent Systems](https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=9670) (2007)... Dedicated courses for recommender systems have been integrated into curriculum of many universities. This has shown how much impacts recommender systems have in general.

## 1.2 What is recommender system?
Previous section provided intuitive sense of recommender systems, now we'll try to define recomender systems more precisely. Recommender systems (RSs) are software tools that are implemented to produce suggestions of items to users. Here, "suggestions" tie to different decision-making processes such as deciding what food to buy, what movie to watch, what music to listen to, what news to read... Items and users are important concepts in this definition.  
**Items** are objects that are recommended. Each item should have its value, which determines how much the item will be useful. Items are characterized by their complexity, which refers to the items' structure, representation... For example, low complexity items are news, web pages, books, movies... Larger complexity items are cameras, phones, PCs...  
**Users** are those who interacts with RSs to get recommendations. RSs usually exploit a wide range of information about users to generate accurate personalized recommendations. RSs use user model to encode users' profiles, needs, preferences... For example, in collaborative filtering approach for movies recommender, users are modeled as a vector of ratings (number 1 to 5).  
**Transactions** are interactions between users and RSs. Transactions are data emerged from interactions between human and computer that is useful for RSs. Transaction data may contain reference to selected items, context descriptions, feedback from users such as ratings. For the time being, ratings are the most popular transaction data. Ratings can be numeric (number of stars for example), or ordinal (such as choices like strongly disagree, disagree, neutral, agree...), or binary (simply ask the users to rate items good or bad)...  
As mentioned above, each item must have a value to determine its usefulness to the user. For our case, we are examining movies, common approach is to define a real-valued function $R(u, i)$ for each user $u$ and movie $i$ such that $R(u, i)$ is the *true* rating user $u$ for movie $i$, which means $R(u, i)$ describe exactly how user $u$ thinks about movie $i$. It's probably impossible to predict exact value of $R(u, i)$, instead, we'll try to compute estimation $\hat{R}(u, i)$, in which $\hat{R}$ denote estimation of the true function $R$. If there are $N$ movies: $i_1, i_2,..., i_N$ ($N$ is often a really big number ranging from milion to bilion in practice), then our RS will compute for the user $u$ all estimated ratings: $\hat{R}(u, i_1), \hat{R}(u, i_2),..., \hat{R}(u, i_N)$. Finally, the RS choose a set of $K$ movies ($K$ is often small, like top-ten or top-hundred): $i_{j_1}, i_{j_2},..., i_{j_K}$ that have the largest estimated ratings from $N$ movies. This process of choosing small number $K$ of items from larger set of $N$ items is called **filtering**.

## 1.3 Different types of recommender systems
Here is an overview of different types of RSs. We observed that these types vary based heavily on the choice of recommendation algorithm, that is, how prediction are made, or, how item's estimated value respect to a user is computed, while some vary in terms of addressed domain, the knowledge used...  
**Collaborative filtering** is an approach that is based on a very simple intuition: *people with similar taste recommend the best*.[^handbook] Basically, the estimated rating for an active user will be computed by other ratings of other users that is similar to the active user in terms of movie ratings. Similarity will be calculated based on rating history of these users. Collaborative filtering has become the most popular technique in RS field.  
**Content-based filtering** takes an different path from collaborative filtering. Instead of focusing on *peer-to-peer* similarity as in collaborative filtering, content-based RSs try to find similarity in *item-to-item*. For movie example, if a user rates a movie positively, content-based RSs will recommend a movie that is the most similar to the rated movie.  
**Demographic recommender system** is a type of RSs that recommend items based on demographic profile of users. Different demographic profiles should be recommended with different items. For example, some websites may be recommended by Google based on language and country of users, or videos could be suggested based on age.  
**Knowledge-based recommender system** is usually used when alternatives such as collaborative filtering and content-based filtering cannot be applied. Knowledge-based RSs are based on explicit knowledge about user needs, preferences, item value criteria (how it is useful for certain user). Knowledge-based RSs can be case-based, in which there is a similarity function estimate how much user needs match the recommendations. Another type is constraint-based, which is similar to case-based in most aspect except how it arrives at the output. While case-based RSs use similarity metrics, constraint-based RSs use explicit rules in predefined knowledge bases to relate customer requirements with item features.  
**Community-based recommender system** follows the idea: *tell me who your friends are, I will tell you who you are*.[^handbook] This type of RSs recommends items based on users' friends. Community-based recommender system can be viewed as a more strict version of collaborative filtering since it relies on preferences of users' friends rather than anonymous individuals.  
**Hybrid recommender system** combines multiple techniques described above into single model. A hybrid RS tries to use certain techniques to fix disadvantages of other techniques. Collaborative filtering suffers from cold start problems, in which there is a small number of rated items making recommendations impossible. We can use other techniques like content-based approach which does not have this limitation. Several combinations have been proposed to create and improve hybrid system.

## 1.4 Selected algorithms for collaborative filtering
According to our survey objectives, we'll focus solely on collaborative filtering (CF) approach and study various kind of algorithms it offered. Over the years, various algorithms have been invented for leveraging collaborative filtering approach. In this study, we'll examine 3 algorithms in order of their complexity: Slope One algorithm, k-Nearest Neighbors (k-NN) based algorithm, and Singular Value Decomposition (SVD) based algorithm.  
**Slope One** is said to be arguably one of the simplest existing algorithms for collaborative filtering. The idea is simple: take the average difference in ratings from other users for target item, then use that average difference to estimate rating of active user on said item just by adding it to the average rating of this user. Their simplicity makes it especially easy to implement them efficiently while their accuracy is often on par with more complicated and computationally expensive algorithms.[^slopeone_wikipedia]  
**k-NN algorithm**, or *neighborhood-based algorithm*, is classic for RSs based on collaborative filtering. k-NN algorithm finds most similar users or items, then calculate estimated rating according to ratings from these similar users or items. Popular similarity measures are cosine similarity, Pearson correlation... In this method, we can compare user-to-user, hence the name user-based CF, likewise, we can also compare item-to-item, hence the name item-based CF. We'll see how to select which approach to follow based on a set of criteria. While k-NN algorithms are intuitive and easy to implement, they can struggle with scalability when dealing with large datasets due to the computational cost of similarity calculations.  
**SVD-based algorithm** employs matrix factorization technique that decomposes the user-item interaction matrix into lower-dimensional matrices. SVD captures latent factors that represent underlying relationships between users and items, allowing for more accurate predictions by generalizing patterns in the data. SVD-based algorithms are effective for capturing hidden patterns and making personalized recommendations, especially in large, sparse datasets. However, SVD can be computationally expensive and requires careful tuning of parameters for optimal performance.

[^handbook]: Recommender System Handbook.
[^slopeone_wikipedia]: Wikipedia on Slope One. Access from [here](https://en.wikipedia.org/wiki/Slope_One).